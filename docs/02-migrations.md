# Database Migrations

## Overview

Vertex AR uses Alembic for database migrations. All schema changes must be managed through migration scripts to ensure consistency across environments.

## Creating Migrations

### 1. Make Model Changes

First, update the SQLAlchemy models in `app/models/`:

```python
# app/models/user.py
class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True)
    email = Column(String, unique=True, index=True)
    # Add new field
    phone = Column(String(20), nullable=True)  # <-- New field
```

### 2. Generate Migration Script

```bash
# Generate automatic migration
docker compose exec app alembic revision --autogenerate -m "Add phone field to users"

# Or create empty migration for manual SQL
docker compose exec app alembic revision -m "Custom migration"
```

### 3. Review Generated Migration

Check the generated file in `alembic/versions/`:

```python
# alembic/versions/xxx_add_phone_field_to_users.py
from alembic import op
import sqlalchemy as sa

revision = 'abc123'
down_revision = 'def456'
branch_labels = None
depends_on = None

def upgrade():
    op.add_column('users', sa.Column('phone', sa.String(20), nullable=True))

def downgrade():
    op.drop_column('users', 'phone')
```

### 4. Customize if Needed

Modify the migration script if automatic generation isn't sufficient:

```python
def upgrade():
    # Add column
    op.add_column('users', sa.Column('phone', sa.String(20), nullable=True))
    
    # Add index
    op.create_index('ix_users_phone', 'users', ['phone'])
    
    # Add constraint
    op.create_check_constraint('chk_phone_format', 'users', "phone ~ '^\\+?[1-9]\\d{1,14}$'")

def downgrade():
    op.drop_constraint('chk_phone_format', 'users')
    op.drop_index('ix_users_phone', 'users')
    op.drop_column('users', 'phone')
```

## Applying Migrations

### Development Environment

```bash
# Apply all pending migrations
docker compose exec app alembic upgrade head

# Apply specific migration
docker compose exec app alembic upgrade abc123

# Check current revision
docker compose exec app alembic current

# View migration history
docker compose exec app alembic history
```

### Production Environment

```bash
# Always check what will be applied first
docker compose exec app alembic upgrade head --sql

# Apply migrations
docker compose exec app alembic upgrade head
```

## Rolling Back Migrations

```bash
# Rollback one migration
docker compose exec app alembic downgrade -1

# Rollback to specific revision
docker compose exec app alembic downgrade abc123

# Rollback to base
docker compose exec app alembic downgrade base
```

## Best Practices

1. **Always backup before migrating in production**
2. **Test migrations locally first**
3. **Review autogenerated migrations carefully**
4. **Keep migrations small and focused**
5. **Include both upgrade and downgrade paths**
6. **Use transactions for complex migrations**

## Common Migration Patterns

### Adding a New Table

```python
def upgrade():
    op.create_table(
        'user_profiles',
        sa.Column('id', sa.Integer, primary_key=True),
        sa.Column('user_id', sa.Integer, sa.ForeignKey('users.id')),
        sa.Column('bio', sa.Text),
        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),
    )
    
def downgrade():
    op.drop_table('user_profiles')
```

### Changing Column Types

```python
def upgrade():
    # SQLite requires recreate, PostgreSQL can alter directly
    with op.batch_alter_table('users') as batch_op:
        batch_op.alter_column('email', type_=sa.String(320))

def downgrade():
    with op.batch_alter_table('users') as batch_op:
        batch_op.alter_column('email', type_=sa.String(255))
```

### Adding Indexes

```python
def upgrade():
    op.create_index('ix_users_email_lower', 'users', [sa.text('LOWER(email)')])
    op.create_index('ix_users_created_at', 'users', ['created_at'])

def downgrade():
    op.drop_index('ix_users_created_at', 'users')
    op.drop_index('ix_users_email_lower', 'users')
```

## Troubleshooting

### Migration Conflicts

If you encounter conflicts when merging branches:

```bash
# Check current head
docker compose exec app alembic heads

# Merge heads
docker compose exec app alembic mergeheads

# Or manually create merge migration
docker compose exec app alembic revision --merge -m "Merge migrations"
```

### Data Migration

For complex data transformations, separate schema and data migrations:

```python
# Schema migration
def upgrade():
    op.add_column('users', sa.Column('full_name', sa.String(255)))

# Data migration (separate file)
def upgrade():
    connection = op.get_bind()
    connection.execute(
        sa.text("UPDATE users SET full_name = CONCAT(first_name, ' ', last_name)")
    )
```