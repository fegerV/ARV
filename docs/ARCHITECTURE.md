# Архитектура системы

Подробное описание архитектуры платформы ARV.

## Обзор

ARV - это B2B SaaS платформа для создания AR-контента, построенная на современной архитектуре с использованием FastAPI, SQLAlchemy и серверного рендеринга. Платформа поддерживает создание AR-контента с распознаванием изображений через MindAR.

## Архитектурные принципы

### 1. Серверный рендеринг (SSR)

- **Подход**: FastAPI + Jinja2 для генерации HTML на сервере
- **Преимущества**: 
  - Быстрая загрузка страниц
  - SEO-friendly
  - Меньше JavaScript на клиенте
  - Простота разработки и поддержки

### 2. Минимальный JavaScript

- **Технологии**: htmx + Alpine.js
- **Принцип**: Максимум функциональности с минимумом кода
- **Преимущества**:
  - Быстрая загрузка
  - Простота отладки
  - Меньше зависимостей

### 3. Асинхронность

- **Подход**: async/await везде, где возможно
- **Компоненты**:
  - FastAPI (асинхронный по умолчанию)
  - SQLAlchemy async
  - asyncpg для PostgreSQL
  - Асинхронные сервисы

### 4. Разделение ответственности

- **API Routes**: Обработка HTTP запросов, валидация
- **Services**: Бизнес-логика
- **Models**: Модели данных
- **Schemas**: Валидация и сериализация
- **Utils**: Вспомогательные функции

## Структура приложения

```
app/
├── main.py                 # Точка входа, настройка FastAPI
├── core/                   # Ядро приложения
│   ├── config.py          # Конфигурация
│   ├── database.py        # Подключение к БД
│   ├── security.py        # Безопасность (JWT, пароли)
│   └── storage_providers.py  # Провайдеры хранения
├── api/                   # API маршруты
│   └── routes/            # Отдельные модули API
├── html/                  # HTML маршруты
│   └── routes/            # Отдельные модули HTML
├── models/               # SQLAlchemy модели
├── schemas/              # Pydantic схемы
├── services/             # Бизнес-логика
├── utils/                 # Вспомогательные функции
└── middleware/           # Middleware (rate limiting)
```

## Компоненты системы

### 1. API Layer (app/api/routes/)

Обрабатывает HTTP запросы и возвращает JSON ответы.

**Основные модули:**
- `auth.py` - Аутентификация (JWT)
- `companies.py` - Управление компаниями
- `projects.py` - Управление проектами
- `ar_content.py` - Управление AR-контентом
- `videos.py` - Управление видео
- `viewer.py` - AR viewer API
- `storage.py` - Управление хранилищем
- `notifications.py` - Уведомления
- `analytics.py` - Аналитика
- `settings.py` - Настройки системы
- `oauth.py` - OAuth интеграции
- `health.py` - Health checks

### 2. HTML Layer (app/html/routes/)

Генерирует HTML страницы через Jinja2 шаблоны.

**Основные модули:**
- `auth.py` - Страницы входа/выхода
- `dashboard.py` - Дашборд
- `companies.py` - Страницы компаний
- `projects.py` - Страницы проектов
- `ar_content.py` - Страницы AR-контента
- `notifications.py` - Страницы уведомлений
- `settings.py` - Страницы настроек
- `storage.py` - Страницы хранилища

### 3. Services Layer (app/services/)

Содержит бизнес-логику приложения.

**Основные сервисы:**
- `marker_service.py` - Работа с маркерами (ARCore: фото = маркер)
- `thumbnail_service.py` - Генерация превью
- `video_scheduler.py` - Логика выбора видео
- `notification_service.py` - Отправка уведомлений
- `settings_service.py` - Управление настройками
- `enhanced_cache_service.py` - Кэширование
- `reliability_service.py` - Circuit breaker, retry

### 4. Models Layer (app/models/)

SQLAlchemy модели для работы с базой данных.

**Основные модели:**
- `User` - Пользователи
- `Company` - Компании
- `Project` - Проекты
- `ARContent` - AR-контент
- `Video` - Видео
- `VideoSchedule` - Расписание видео
- `Notification` - Уведомления
- `StorageConnection` - Подключения к хранилищу

### 5. Core Layer (app/core/)

Ядро приложения - конфигурация, БД, безопасность.

**Компоненты:**
- `config.py` - Настройки из переменных окружения
- `database.py` - Подключение к БД, сессии
- `security.py` - JWT, хеширование паролей
- `storage_providers.py` - Абстракция хранилища

## Потоки данных

### 1. Создание AR-контента

```
1. Пользователь загружает фото и видео через HTML форму
   ↓
2. HTML Route (ar_content.py) получает файлы
   ↓
3. API Route (ar_content.py) обрабатывает загрузку
   ↓
4. Storage Provider сохраняет файлы
   ↓
5. MindAR Generator создает маркер
   ↓
6. Thumbnail Service создает превью
   ↓
7. Данные сохраняются в БД через Models
   ↓
8. Возвращается ответ пользователю
```

### 2. Просмотр AR-контента

```
1. Пользователь открывает AR viewer по unique_id
   ↓
2. Viewer Route получает AR-контент из БД
   ↓
3. Video Scheduler выбирает активное видео
   ↓
4. Возвращается маркер и видео
   ↓
5. Браузер загружает MindAR
   ↓
6. MindAR распознает изображение
   ↓
7. Видео воспроизводится поверх изображения
   ↓
8. При окончании видео запрашивается следующее
```

### 3. Выбор активного видео

**Приоритет выбора:**

1. **Видео с активным расписанием** - если есть видео с активным временным окном
2. **Активное видео по active_video_id** - если установлено вручную
3. **Ротация (sequential/cyclic)** - автоматическое переключение
4. **Fallback** - любое активное видео

**Режимы ротации:**
- `none` - Одно фиксированное видео
- `sequential` - Последовательное переключение (1→2→3→...→последнее)
- `cyclic` - Циклическое переключение (1→2→3→...→1→2→...)

## База данных

### Подключение

- **Разработка**: SQLite (sqlite+aiosqlite)
- **Продакшен**: PostgreSQL (postgresql+asyncpg)
- **ORM**: SQLAlchemy 2.0 (асинхронный)
- **Миграции**: Alembic

### Архитектура БД

```
Users
  ↓
Companies ← Projects ← ARContent → Videos
                              ↓
                        VideoSchedules
```

## Хранилище файлов

### Структура

```
storage/
└── VertexAR/
    └── {project_name}/
        └── {order_number}/
            ├── photo.{ext}
            ├── video.{ext}
            ├── marker.mind
            ├── thumbnail.webp
            └── qr_code.png
```

### Провайдеры

- **LocalStorageProvider** - Локальное файловое хранилище
- **S3StorageProvider** (планируется) - AWS S3
- **YandexStorageProvider** (планируется) - Yandex Object Storage

## Аутентификация и авторизация

### JWT токены

- **Алгоритм**: HS256
- **Время жизни**: Настраивается (по умолчанию 24 часа)
- **Хранение**: HTTP-only cookies для HTML, Bearer token для API

### Защита

- **Rate limiting**: 5 попыток входа за 15 минут
- **Блокировка аккаунта**: После превышения лимита
- **Валидация паролей**: SHA-256 хеширование

## Middleware

### CORS Middleware

- Настройка разрешенных доменов
- Поддержка credentials

### GZip Middleware

- Сжатие ответов > 500 байт
- Улучшение производительности

### Rate Limiting

- Защита от брутфорса
- Ограничение запросов по IP

## Фоновые задачи

### Background Tasks

- Генерация маркеров
- Создание превью
- Отправка уведомлений
- Обработка видео

**Реализация**: FastAPI BackgroundTasks + планируется Celery/Redis

## Логирование

### Structured Logging

- **Библиотека**: structlog
- **Формат**: JSON в продакшене, консоль в разработке
- **Уровни**: DEBUG, INFO, WARNING, ERROR

## Мониторинг

### Health Checks

- `/api/health` - Проверка состояния системы
- Проверка БД
- Проверка хранилища

### Метрики (планируется)

- Prometheus метрики
- Grafana дашборды
- Sentry для ошибок

## Безопасность

### Защита данных

- Валидация входных данных через Pydantic
- SQL injection защита через ORM
- XSS защита через экранирование в Jinja2
- CSRF защита (планируется)

### Конфигурация

- Секретные ключи через переменные окружения
- Валидация настроек при старте
- Предупреждения о небезопасных настройках

## Масштабируемость

### Горизонтальное масштабирование

- Stateless приложение (JWT токены)
- Поддержка нескольких инстансов
- Общее хранилище файлов

### Вертикальное масштабирование

- Асинхронная обработка
- Connection pooling для БД
- Кэширование (планируется Redis)

## Развертывание

### Docker

- Мульти-стадийная сборка
- Отдельные Dockerfile для dev/test/prod
- Docker Compose для локальной разработки

### Переменные окружения

- Все настройки через .env
- Валидация при старте
- Разные конфигурации для окружений

## Диаграммы

### Компонентная диаграмма

```
┌─────────────┐
│   Browser   │
└──────┬──────┘
       │
       ▼
┌─────────────────┐
│   FastAPI App   │
│  ┌───────────┐  │
│  │ API Routes │  │
│  └─────┬─────┘  │
│  ┌─────▼─────┐  │
│  │ Services  │  │
│  └─────┬─────┘  │
│  ┌─────▼─────┐  │
│  │  Models   │  │
│  └─────┬─────┘  │
└────────┼────────┘
         │
    ┌────▼────┐
    │   DB    │
    └─────────┘
```

### Поток создания AR-контента

```
User → HTML Form → API Route → Service → Storage → DB
                                    ↓
                              MindAR Generator
                                    ↓
                              Marker File
```

## Расширяемость

### Добавление новых провайдеров хранения

1. Наследовать от `StorageProvider`
2. Реализовать абстрактные методы
3. Зарегистрировать в `get_storage_provider()`

### Добавление новых сервисов

1. Создать класс в `app/services/`
2. Использовать в routes через dependency injection
3. Добавить логирование через structlog

### Добавление новых моделей

1. Создать модель в `app/models/`
2. Создать схему в `app/schemas/`
3. Создать миграцию через Alembic

## Лучшие практики

1. **Всегда используйте async/await** для I/O операций
2. **Валидируйте входные данные** через Pydantic
3. **Логируйте важные события** через structlog
4. **Обрабатывайте ошибки** явно с понятными сообщениями
5. **Используйте type hints** везде
6. **Тестируйте критичные компоненты**
7. **Документируйте API** через docstrings

## Дополнительные ресурсы

- [FastAPI Best Practices](https://fastapi.tiangolo.com/tutorial/)
- [SQLAlchemy Async](https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.html)
- [Structured Logging](https://www.structlog.org/)
